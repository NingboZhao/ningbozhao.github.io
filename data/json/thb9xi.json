{
  "body_html": "<p><span style=\"color: #545454;\">开窗函数：定义 </span><code>行</code><span style=\"color: #545454;\"> 为 </span><code>列</code></p><p><span style=\"color: #545454;\">简单讲，就是在你查询的结果上，直接多出一列值（可以是聚合值或是排序号），特征就是带有 </span><code>over()</code><span style=\"color: #545454;\">。</span></p><p><br /></p><h4 id=\"ntile\">NTILE 切片(前三分之一)</h4><ul><li>NTILE(n)，用于将分组数据按照顺序切分成n片，返回当前切片值</li><li>NTILE不支持ROWS BETWEEN，</li><li>比如 NTILE(2) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW)</li><li>如果切片不均匀，默认增加第一个切片的分布</li></ul><p>场景：假如我们想要每位顾客购买金额前1/3的交易记录,我们便可以使用这个函数</p><pre data-lang=\"sql\"><code>select name,orderdate,cost,\n       ntile(3) over() as sample1 , --全局数据切片\n       ntile(3) over(partition by name), -- 按照name进行分组,在分组内将数据切成3份\n       ntile(3) over(order by cost),--全局按照cost升序排列,数据切成3份\n       ntile(3) over(partition by name order by cost ) --按照name分组，在分组内按照cost升序排列,数据切成3份\nfrom t_window</code></pre><p><br /></p><h4 id=\"rownumberrankdenserank\">row_number、rank、dense_rank</h4><ul><li>row_number()从1开始，按照顺序，生成分组内记录的序列,row_number()的值不会存在重复,当排序的值相同时,按照表中记录的顺序进行排列</li><li>RANK() 生成数据项在分组中的排名，排名相等会在名次中留下空位</li><li>DENSE_RANK() 生成数据项在分组中的排名，排名相等会在名次中不会留下空位</li></ul><p><em>rank和dense_rank的区别在于排名相等时会不会留下空位.**</em></p><pre data-lang=\"sql\"><code>SELECT \ncookieid,\ncreatetime,\npv,\nRANK() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn1,\nDENSE_RANK() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn2,\nROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY pv DESC) AS rn3 \nFROM lxw1234 \nWHERE cookieid = 'cookie1';\n\ncookieid day           pv       rn1     rn2     rn3 \ncookie1 2015-04-12      7       1       1       1\ncookie1 2015-04-11      5       2       2       2\ncookie1 2015-04-15      4       3       3       3\ncookie1 2015-04-16      4       3       3       4\ncookie1 2015-04-13      3       5       4       5\ncookie1 2015-04-14      2       6       5       6\ncookie1 2015-04-10      1       7       6       7\n\nrn1: 15号和16号并列第3, 13号排第5\nrn2: 15号和16号并列第3, 13号排第4\nrn3: 如果相等，则按记录值排序，生成唯一的次序，如果所有记录值都相等，或许会随机排吧。</code></pre><p><br /></p><h4 id=\"4g1dL\">LAG和LEAD函数</h4><p>这两个函数为常用的窗口函数,可以返回上下数据行的数据. </p><p>以我们的订单表为例,假如我们想要查看顾客上次的购买时间可以这样去查询</p><pre data-lang=\"sql\"><code>select name,orderdate,cost,\nlag(orderdate,1,'1900-01-01') over(partition by name order by orderdate ) as time1,\nlag(orderdate,2) over (partition by name order by orderdate) as time2\nfrom t_window;\n\nname    orderdate   cost    time1   time2\njack    2015-01-01  10  1900-01-01  NULL\njack    2015-01-05  46  2015-01-01  NULL\njack    2015-01-08  55  2015-01-05  2015-01-01\njack    2015-02-03  23  2015-01-08  2015-01-05\njack    2015-04-06  42  2015-02-03  2015-01-08\nmart    2015-04-08  62  1900-01-01  NULL\nmart    2015-04-09  68  2015-04-08  NULL\nmart    2015-04-11  75  2015-04-09  2015-04-08\nmart    2015-04-13  94  2015-04-11  2015-04-09\nneil    2015-05-10  12  1900-01-01  NULL\nneil    2015-06-12  80  2015-05-10  NULL\ntony    2015-01-02  15  1900-01-01  NULL\ntony    2015-01-04  29  2015-01-02  NULL\ntony    2015-01-07  50  2015-01-04  2015-01-02\n--------------------- \ntime1取的为按照name进行分组,分组内升序排列,取上一行数据的值.\n\ntime2取的为按照name进行分组，分组内升序排列,取上面2行的数据的值,注意当lag函数为设置行数值时,默认为1行.未设定取不到时的默认值时,取null值.\n\nlead函数与lag函数方向相反,取向下的数据.</code></pre><p><br /></p><h4 id=\"P4bZf\">first_value和last_value</h4><p>first_value取分组内排序后，截止到当前行，第一个值 </p><p>last_value取分组内排序后，截止到当前行，最后一个值</p><pre data-lang=\"sql\"><code>select name,orderdate,cost,\nfirst_value(orderdate) over(partition by name order by orderdate) as time1,\nlast_value(orderdate) over(partition by name order by orderdate) as time2\nfrom t_window\n--------------------- \nname    orderdate   cost    time1   time2\njack    2015-01-01  10  2015-01-01  2015-01-01\njack    2015-01-05  46  2015-01-01  2015-01-05\njack    2015-01-08  55  2015-01-01  2015-01-08\njack    2015-02-03  23  2015-01-01  2015-02-03\njack    2015-04-06  42  2015-01-01  2015-04-06\nmart    2015-04-08  62  2015-04-08  2015-04-08\nmart    2015-04-09  68  2015-04-08  2015-04-09\nmart    2015-04-11  75  2015-04-08  2015-04-11\nmart    2015-04-13  94  2015-04-08  2015-04-13\nneil    2015-05-10  12  2015-05-10  2015-05-10\nneil    2015-06-12  80  2015-05-10  2015-06-12\ntony    2015-01-02  15  2015-01-02  2015-01-02\ntony    2015-01-04  29  2015-01-02  2015-01-04\ntony    2015-01-07  50  2015-01-02  2015-01-07</code></pre><p><br /></p><h4 id=\"DT2j0\">SUM,AVG,MIN,MAX</h4><p><span class=\"lake-fontsize-12\" style=\"color: #4F4F4F;\">用于实现分组内所有和连续累积的统计。</span></p><p><br /></p><pre data-lang=\"sql\"><code>cookieid string,  \ncreatetime string,\npv INT  \ncookie1 2015-04-10      1  \ncookie1 2015-04-11      5  \ncookie1 2015-04-12      7  \ncookie1 2015-04-13      3  \ncookie1 2015-04-14      2  \ncookie1 2015-04-15      4  \ncookie1 2015-04-16      4  </code></pre><p><span class=\"lake-fontsize-12\" style=\"color: #4F4F4F;\"><br /></span></p><pre data-lang=\"sql\"><code>SELECT cookieid,\n    createtime,\n    pv,\n    SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行\n    SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 \n    SUM(pv) OVER(PARTITION BY cookieid) AS pv3,\t--分组内所有行\n    SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4,  --当前行+往前3行\n    SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5,  --当前行+往前3行+往后1行\n    SUM(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6  ---当前行+往后所有行  \n    FROM lxw1234;\n     \n    cookieid createtime     pv      pv1     pv2     pv3     pv4     pv5      pv6 \n    -----------------------------------------------------------------------------\n    cookie1  2015-04-10      1       1       1       26      1       6       26\n    cookie1  2015-04-11      5       6       6       26      6       13      25\n    cookie1  2015-04-12      7       13      13      26      13      16      20\n    cookie1  2015-04-13      3       16      16      26      16      18      13\n    cookie1  2015-04-14      2       18      18      26      17      21      10\n    cookie1  2015-04-15      4       22      22      26      16      20      8\n    cookie1  2015-04-16      4       26      26      26      13      13      4\n    \npv1: 分组内从起点到当前行的pv累积，如，11号的pv1=10号的pv+11号的pv, 12号=10号+11号+12号\npv2: 同pv1\npv3: 分组内(cookie1)所有的pv累加\npv4: 分组内当前行+往前3行，如，11号=10号+11号， 12号=10号+11号+12号， 13号=10号+11号+12号+13号， 14号=11号+12号+13号+14号\npv5: 分组内当前行+往前3行+往后1行，如，14号=11号+12号+13号+14号+15号=5+7+3+2+4=21\npv6: 分组内当前行+往后所有行，如，13号=13号+14号+15号+16号=3+2+4+4=13，14号=14号+15号+16号=2+4+4=10</code></pre><p><span class=\"lake-fontsize-12\" style=\"color: #4F4F4F;\"><br /></span></p><p>如果不指定ROWS BETWEEN,默认为从起点到当前行;</p><p>如果不指定ORDER BY，则将分组内所有值累加;</p><p>关键是理解ROWS BETWEEN含义,也叫做WINDOW子句：</p><p>PRECEDING：往前</p><p>FOLLOWING：往后</p><p>CURRENT ROW：当前行</p><p>UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING：表示到后面的终点</p><p>其他AVG，MIN，MAX，和SUM用法一样。</p><p><br /></p><pre data-lang=\"sql\"><code>--AVG\n    SELECT cookieid,\n    createtime,\n    pv,\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 \n    AVG(pv) OVER(PARTITION BY cookieid) AS pv3,\t--分组内所有行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4, --当前行+往前3行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5, --当前行+往前3行+往后1行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6  ---当前行+往后所有行  \n    FROM lxw1234; \n    cookieid createtime     pv      pv1     pv2     pv3     pv4     pv5      pv6 \n    -----------------------------------------------------------------------------\n    cookie1 2015-04-10      1       1.0     1.0     3.7142857142857144      1.0     3.0     3.7142857142857144\n    cookie1 2015-04-11      5       3.0     3.0     3.7142857142857144      3.0     4.333333333333333       4.166666666666667\n    cookie1 2015-04-12      7       4.333333333333333       4.333333333333333       3.7142857142857144      4.333333333333333       4.0     4.0\n    cookie1 2015-04-13      3       4.0     4.0     3.7142857142857144      4.0     3.6     3.25\n    cookie1 2015-04-14      2       3.6     3.6     3.7142857142857144      4.25    4.2     3.3333333333333335\n    cookie1 2015-04-15      4       3.6666666666666665      3.6666666666666665      3.7142857142857144      4.0     4.0     4.0\n    cookie1 2015-04-16      4       3.7142857142857144      3.7142857142857144      3.7142857142857144      3.25    3.25    4.0\n\n--AVG\n    SELECT cookieid,\n    createtime,\n    pv,\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 \n    AVG(pv) OVER(PARTITION BY cookieid) AS pv3,\t--分组内所有行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4, --当前行+往前3行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5, --当前行+往前3行+往后1行\n    AVG(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6  ---当前行+往后所有行  \n    FROM lxw1234; \n    cookieid createtime     pv      pv1     pv2     pv3     pv4     pv5      pv6 \n    -----------------------------------------------------------------------------\n    cookie1 2015-04-10      1       1.0     1.0     3.7142857142857144      1.0     3.0     3.7142857142857144\n    cookie1 2015-04-11      5       3.0     3.0     3.7142857142857144      3.0     4.333333333333333       4.166666666666667\n    cookie1 2015-04-12      7       4.333333333333333       4.333333333333333       3.7142857142857144      4.333333333333333       4.0     4.0\n    cookie1 2015-04-13      3       4.0     4.0     3.7142857142857144      4.0     3.6     3.25\n    cookie1 2015-04-14      2       3.6     3.6     3.7142857142857144      4.25    4.2     3.3333333333333335\n    cookie1 2015-04-15      4       3.6666666666666665      3.6666666666666665      3.7142857142857144      4.0     4.0     4.0\n    cookie1 2015-04-16      4       3.7142857142857144      3.7142857142857144      3.7142857142857144      3.25    3.25    4.0\n\n--MAX\n    SELECT cookieid,\n    createtime,\n    pv,\n    MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS pv1, -- 默认为从起点到当前行\n    MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS pv2, --从起点到当前行，结果同pv1 \n    MAX(pv) OVER(PARTITION BY cookieid) AS pv3,\t--分组内所有行\n    MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS pv4, --当前行+往前3行\n    MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING) AS pv5, --当前行+往前3行+往后1行\n    MAX(pv) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS pv6  ---当前行+往后所有行  \n    FROM lxw1234;\n     \n    cookieid createtime     pv      pv1     pv2     pv3     pv4     pv5      pv6 \n    -----------------------------------------------------------------------------\n    cookie1 2015-04-10      1       1       1       7       1       5       7\n    cookie1 2015-04-11      5       5       5       7       5       7       7\n    cookie1 2015-04-12      7       7       7       7       7       7       7\n    cookie1 2015-04-13      3       7       7       7       7       7       4\n    cookie1 2015-04-14      2       7       7       7       7       7       4\n    cookie1 2015-04-15      4       7       7       7       7       7       4\n    cookie1 2015-04-16      4       7       7       7       4       4       4</code></pre><p><br /></p><p><br /></p><h4 id=\"RMYKs\">GROUPING SETS,GROUPING__ID,CUBE,ROLLUP</h4><p>这几个分析函数通常用于OLAP中，不能累加，而且需要根据不同维度上钻和下钻的指标统计，比如，分小时、天、月的UV数。</p><p><br /></p><pre data-lang=\"sql\"><code>month STRING,  \nday STRING,   \ncookieid STRING  \n\n2015-03 2015-03-10      cookie1  \n2015-03 2015-03-10      cookie5  \n2015-03 2015-03-12      cookie7  \n2015-04 2015-04-12      cookie3  \n2015-04 2015-04-13      cookie2  \n2015-04 2015-04-13      cookie4  \n2015-04 2015-04-16      cookie4  \n2015-03 2015-03-10      cookie2  \n2015-03 2015-03-10      cookie3  \n2015-04 2015-04-12      cookie5  \n2015-04 2015-04-13      cookie6  \n2015-04 2015-04-15      cookie3  \n2015-04 2015-04-15      cookie2  \n2015-04 2015-04-16      cookie1  </code></pre><p><br /></p><p>在一个GROUP BY查询中，根据不同的维度组合进行聚合，等价于将不同维度的GROUP BY结果集进行UNION ALL。其中的 GROUPING__ID，表示结果属于哪一个分组集合。</p><p><br /></p><pre data-lang=\"sql\"><code>SELECT \n    month,\n    day,\n    COUNT(DISTINCT cookieid) AS uv,\n    GROUPING__ID \n    FROM lxw1234 \n    GROUP BY month,day \n    GROUPING SETS (month,day) \n    ORDER BY GROUPING__ID;\n     \n    month      day            uv      GROUPING__ID\n    ------------------------------------------------\n    2015-03    NULL            5       1\n    2015-04    NULL            6       1\n    NULL       2015-03-10      4       2\n    NULL       2015-03-12      1       2\n    NULL       2015-04-12      2       2\n    NULL       2015-04-13      3       2\n    NULL       2015-04-15      2       2\n    NULL       2015-04-16      2       2\n     \n     \n    等价于 \n    SELECT month,NULL,COUNT(DISTINCT cookieid) AS uv,1 AS GROUPING__ID FROM lxw1234 GROUP BY month \n    UNION ALL \n    SELECT NULL,day,COUNT(DISTINCT cookieid) AS uv,2 AS GROUPING__ID FROM lxw1234 GROUP BY day</code></pre><p><br /></p><pre data-lang=\"sql\"><code> SELECT \n    month,\n    day,\n    COUNT(DISTINCT cookieid) AS uv,\n    GROUPING__ID \n    FROM lxw1234 \n    GROUP BY month,day \n    GROUPING SETS (month,day,(month,day)) \n    ORDER BY GROUPING__ID;\n     \n    month         day             uv      GROUPING__ID\n    ------------------------------------------------\n    2015-03       NULL            5       1\n    2015-04       NULL            6       1\n    NULL          2015-03-10      4       2\n    NULL          2015-03-12      1       2\n    NULL          2015-04-12      2       2\n    NULL          2015-04-13      3       2\n    NULL          2015-04-15      2       2\n    NULL          2015-04-16      2       2\n    2015-03       2015-03-10      4       3\n    2015-03       2015-03-12      1       3\n    2015-04       2015-04-12      2       3\n    2015-04       2015-04-13      3       3\n    2015-04       2015-04-15      2       3\n    2015-04       2015-04-16      2       3\n     \n     \n    等价于\n    SELECT month,NULL,COUNT(DISTINCT cookieid) AS uv,1 AS GROUPING__ID FROM lxw1234 GROUP BY month \n    UNION ALL \n    SELECT NULL,day,COUNT(DISTINCT cookieid) AS uv,2 AS GROUPING__ID FROM lxw1234 GROUP BY day\n    UNION ALL \n    SELECT month,day,COUNT(DISTINCT cookieid) AS uv,3 AS GROUPING__ID FROM lxw1234 GROUP BY month,day</code></pre><p><br /></p><h4 id=\"nmB3B\">CUBE</h4><p><span class=\"lake-fontsize-12\" style=\"color: #4F4F4F;\">根据GROUP BY的维度的所有组合进行聚合。</span></p><p><br /></p><pre data-lang=\"sql\"><code> SELECT \n    month,\n    day,\n    COUNT(DISTINCT cookieid) AS uv,\n    GROUPING__ID \n    FROM lxw1234 \n    GROUP BY month,day \n    WITH CUBE \n    ORDER BY GROUPING__ID;\n     \n     \n    month           day             uv     GROUPING__ID\n    --------------------------------------------\n    NULL            NULL            7       0\n    2015-03         NULL            5       1\n    2015-04         NULL            6       1\n    NULL            2015-04-12      2       2\n    NULL            2015-04-13      3       2\n    NULL            2015-04-15      2       2\n    NULL            2015-04-16      2       2\n    NULL            2015-03-10      4       2\n    NULL            2015-03-12      1       2\n    2015-03         2015-03-10      4       3\n    2015-03         2015-03-12      1       3\n    2015-04         2015-04-16      2       3\n    2015-04         2015-04-12      2       3\n    2015-04         2015-04-13      3       3\n    2015-04         2015-04-15      2       3\n     \n     \n     \n    等价于\n    SELECT NULL,NULL,COUNT(DISTINCT cookieid) AS uv,0 AS GROUPING__ID FROM lxw1234\n    UNION ALL \n    SELECT month,NULL,COUNT(DISTINCT cookieid) AS uv,1 AS GROUPING__ID FROM lxw1234 GROUP BY month \n    UNION ALL \n    SELECT NULL,day,COUNT(DISTINCT cookieid) AS uv,2 AS GROUPING__ID FROM lxw1234 GROUP BY day\n    UNION ALL \n    SELECT month,day,COUNT(DISTINCT cookieid) AS uv,3 AS GROUPING__ID FROM lxw1234 GROUP BY month,day</code></pre><p><br /></p><h4 id=\"NnoW0\">ROLLUP</h4><p><span class=\"lake-fontsize-12\" style=\"color: #4F4F4F;\">是CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合。</span></p><p><br /></p><pre data-lang=\"sql\"><code>\n    比如，以month维度进行层级聚合：\n    SELECT \n    month,\n    day,\n    COUNT(DISTINCT cookieid) AS uv,\n    GROUPING__ID  \n    FROM lxw1234 \n    GROUP BY month,day\n    WITH ROLLUP \n    ORDER BY GROUPING__ID;\n     \n    month  \t     day             uv     GROUPING__ID\n    ---------------------------------------------------\n    NULL             NULL            7       0\n    2015-03          NULL            5       1\n    2015-04          NULL            6       1\n    2015-03          2015-03-10      4       3\n    2015-03          2015-03-12      1       3\n    2015-04          2015-04-12      2       3\n    2015-04          2015-04-13      3       3\n    2015-04          2015-04-15      2       3\n    2015-04          2015-04-16      2       3\n     \n    可以实现这样的上钻过程：\n    月天的UV-&gt;月的UV-&gt;总UV</code></pre><p><br /></p><pre data-lang=\"sql\"><code>--把month和day调换顺序，则以day维度进行层级聚合：\n     \n    SELECT \n    day,\n    month,\n    COUNT(DISTINCT cookieid) AS uv,\n    GROUPING__ID  \n    FROM lxw1234 \n    GROUP BY day,month \n    WITH ROLLUP \n    ORDER BY GROUPING__ID;\n     \n     \n    day  \t    month              uv     GROUPING__ID\n    -------------------------------------------------------\n    NULL            NULL               7       0\n    2015-04-13      NULL               3       1\n    2015-03-12      NULL               1       1\n    2015-04-15      NULL               2       1\n    2015-03-10      NULL               4       1\n    2015-04-16      NULL               2       1\n    2015-04-12      NULL               2       1\n    2015-04-12      2015-04            2       3\n    2015-03-10      2015-03            4       3\n    2015-03-12      2015-03            1       3\n    2015-04-13      2015-04            3       3\n    2015-04-15      2015-04            2       3\n    2015-04-16      2015-04            2       3\n     \n    可以实现这样的上钻过程：\n    天月的UV-&gt;天的UV-&gt;总UV\n    （这里，根据天和月进行聚合，和根据天聚合结果一样，因为有父子关系，如果是其他维度组合的话，就会不一样）</code></pre><p><br /></p><p>这种函数，需要结合实际场景和数据去使用和研究，只看说明的话，很难理解。</p><p>官网的介绍： https://cwiki.apache.org/confluence/display/Hive/Enhanced+Aggregation%2C+Cube%2C+Grouping+and+Rollup</p><p>原文地址 http://lxw1234.com/archives/tag/hive-window-functions</p><p>参考：http://blog.csdn.net/xiepeifeng/article/details/42676567</p><p>http://www.cnblogs.com/skyEva/p/5730531.html</p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p>根据使用的目的，开窗函数可以分为两类：聚合开窗函数和排序开窗函数。</p><p>下面主要解析四种常用的排序开窗函数:</p><p>1、ROW_NUMBER() OVER();</p><p>2、RANK() OVER();</p><p>3、DENSE_RANK() OVER();</p><p>4、NTILE(n) OVER().</p><p>count() over(partition by ... order by ...)：求分组后的总数。</p><p>max() over(partition by ... order by ...)：求分组后的最大值。</p><p>min() over(partition by ... order by ...)：求分组后的最小值。</p><p>avg() over(partition by ... order by ...)：求分组后的平均值。</p><p>lag() over(partition by ... order by ...)：取出前n行数据。　　</p><p>lead() over(partition by ... order by ...)：取出后n行数据。</p><p>ratio_to_report() over(partition by ... order by ...)：Ratio_to_report() 括号中就是分子，over() 括号中就是分母。</p><p>percent_rank() over(partition by ... order by ...)：</p>",
  "slug": 1730939,
  "title": "Hive 窗口函数"
}