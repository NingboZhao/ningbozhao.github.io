{
  "body_html": "<p>前提准备：</p><p>两个表 user和order</p><table class=\"lake-table\" style=\"width: 751px;\"><colgroup><col width=\"375\"></col><col width=\"375\"></col></colgroup><tbody><tr><td><p>user</p></td><td><p>order</p></td></tr><tr><td><p><br /></p><img src=\"https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/png/e7e09829-0484-401d-8286-228364f30a73.png#width=401\" style=\"max-width: 600px; width: 401px;\" /></td><td><p><br /></p><img src=\"https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/png/2b70181b-27b8-4899-9be7-150af3b1aafb.png#width=244\" style=\"max-width: 600px; width: 244px;\" /><p><br /></p></td></tr></tbody></table><h1 id=\"in\"><a href=\"#in\"></a>In</h1><p>确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。</p><pre data-lang=\"sql\"><code>SELECT * FROM `user`\nWHERE `user`.id IN (SELECT `order`.user_id FROM `order`)</code></pre><p>该语句执行结果如下：　</p><p><img src=\"https://images2015.cnblogs.com/blog/1104082/201702/1104082-20170226021558210-635714085.png#width=\" style=\"max-width: 600px;\" /></p><p>它的执行流程是什么样子的呢？让我们一起来看一下。</p><p>首先，在数据库内部，查询子查询，执行如下代码：</p><pre data-lang=\"sql\"><code>SELECT `order`.user_id FROM `order`</code></pre><p>执行完毕后，得到结果如下：　　</p><p><img src=\"https://images2015.cnblogs.com/blog/1104082/201702/1104082-20170226021913023-31075463.png#width=\" style=\"max-width: 600px;\" /></p><p>此时，将查询到的结果和原有的user表做一个笛卡尔积，结果如下：</p><p><img src=\"https://images2015.cnblogs.com/blog/1104082/201702/1104082-20170226022145538-205031549.png#width=\" style=\"max-width: 600px;\" /></p><p>此时，再根据我们的<code>user.id IN order.user_id</code>的条件，将结果进行筛选（既比较id列和user_id 列的值是否相等，将不相等的删除）。最后，得到两条符合条件的数据。<br />　　　　</p><p><img src=\"https://images2015.cnblogs.com/blog/1104082/201702/1104082-20170226022446179-827444722.png#width=\" style=\"max-width: 600px;\" /></p><p><br /></p><h1 id=\"exists\"><a href=\"#exists\"></a>Exists</h1><p>指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中：</p><pre data-lang=\"sql\"><code>SELECT `user`.* FROM `user`\nWHERE EXISTS (SELECT `order`.user_id FROM `order` WHERE `user`.id = `order`.user_id)</code></pre><p>这条sql语句的执行结果和上面的in的执行结果是一样的。</p><p>但是，不一样的是它们的执行流程完全不一样：使用exists关键字进行查询的时候，首先，我们先查询的不是子查询的内容，而是查我们的主查询的表，也就是说，我们先执行的sql语句是：<code>SELECT `user`.* FROM `user` </code></p><p>然后，根据表的每一条记录，执行以下语句，依次去判断where后面的条件是否成立：</p><pre data-lang=\"sql\"><code>EXISTS (SELECT `order`.user_id FROM `order` WHERE `user`.id = `order`.user_id)</code></pre><p>如果成立则返回<code>true</code>不成立则返回<code>false</code>。如果返回的是true的话，则该行结果保留，如果返回的是false的话，则删除该行，最后将得到的结果返回。</p><p><br /></p><h1 id=\"uGQDo\"><a href=\"#区别及应用场景\"></a>区别及应用场景</h1><p>in 和 exists的区别: 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</p><p><br /></p><p>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</p><p><br /></p><p>in 是把外表和内表作hash连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</p><p><br /></p><h1 id=\"E5qjg\"><a href=\"#not-in-和not-exists\"></a>not in 和not exists</h1><p>　　　　如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>",
  "slug": 582461,
  "title": "MySQL In&Exist"
}