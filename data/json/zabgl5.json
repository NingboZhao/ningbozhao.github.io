{
  "body_html": "<h2 id=\"iem1t\"><a href=\"#普通like\"></a>普通LIKE</h2><pre data-lang=\"sql\"><code>一般情况下like模糊查询的写法为（field已建立索引）：\nSELECT column FROM table WHERE field like '%keyword%'</code></pre><p>上面的语句用explain解释来看，SQL语句并未用到索引，而且是全表搜索，如果在数据量超大的时候，可想而知最后的效率会是这样。对比下面的写法：</p><pre data-lang=\"sql\"><code>SELECT column FROM table WHERE field like 'keyword%'</code></pre><p>这样的写法用explain解释看到，SQL语句使用了索引，搜索的效率大大的提高了！</p><p><br /></p><h2 id=\"Tfknl\"><a href=\"#locate函数\"></a>LOCATE函数</h2><p><code>LOCATE（'substr',str,pos）</code></p><p>在MYSQL中，我们会遇到<span style=\"color: #FA541C;\">在某个字符串中</span>查找<span style=\"color: #FA541C;\">指定的某个或几个字</span>符，一般情况下，我们可以通过LIKE模糊查询来实现查找过程，，本文主要测试了LOCATE函数的用法。<br /></p><p>LOCATE(substr,str)<br />该函数表示返回字符串 str中子字符串substr的第一个出现位置；如若substr 不在str中，则返回值为0。</p><p>LOCATE(substr,str,pos)<br />该函数表示返回字符串 str中子字符串substr的第一个出现位置, 起始位置在pos。如若substr 不在str中，则返回值为0。</p><pre data-lang=\"sql\"><code>SELECT column FROM table WHERE LOCATE('keyword', field)&gt;0</code></pre><p>备注：keyword是要搜索的内容，field为被匹配的字段，查询出所有存在keyword的数据</p><p><br /></p><h2 id=\"l7v0J\"><a href=\"#position函数\"></a>POSITION函数</h2><p><code>POSITION(substr IN str)</code></p><p>该函数表示返回字符串 str中子字符串substr的第一个出现位置；如若substr 不在str中，则返回值为0。</p><p>position可以看做是locate的别名，功能跟locate一样</p><pre data-lang=\"sql\"><code>SELECT column FROM table WHERE POSITION('keyword' IN filed)</code></pre><p><br /></p><h2 id=\"2N9F0\"><a href=\"#instr函数\"></a>INSTR函数</h2><p><code>INSTR(str,substr)</code><br />该函数表示返回字符串 str中子字符串substr的第一个出现位置；如若substr 不在str中，则返回值为0。这和LOCATE()的双参数形式相同，只是参数的顺序被颠</p><pre data-lang=\"sql\"><code>SELECT `column` FROM `table` WHERE INSTR(`field`, 'keyword' )&gt;0</code></pre><p><br /></p><h2 id=\"find_in_set\"><a href=\"#find_in_set\"></a>FIND_IN_SET</h2><p>除了上述的方法外，还有一个函数FIND_IN_SET <code>FIND_IN_SET(str1,str2)</code></p><p>返回str2中str1所在的位置索引，其中str2必须以&quot;,&quot;分割开。</p><pre data-lang=\"sql\"><code>SELECT * FROM `person` WHERE FIND_IN_SET('apply',`name`)</code></pre><p><br /></p>",
  "slug": 584225,
  "title": "LIKE 效率提升"
}